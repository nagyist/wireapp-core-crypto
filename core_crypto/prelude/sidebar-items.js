window.SIDEBAR_ITEMS = {"enum":[["CiphersuiteName","MLS ciphersuites."],["CryptoError","CoreCrypto errors"],["CryptoboxMigrationError","Wrapper for errors that can happen during a Cryptobox migration"],["MlsError","MLS-specific error wrapper - see github.com/openmls/openmls for details"],["MlsProposal","Internal representation of proposal to ease further additions"],["MlsPublicGroupStateEncryptionType","PublicGroupStateEncryptionType"],["MlsRatchetTreeType","RatchetTreeType"],["MlsWirePolicy","Wrapper over WireFormatPolicy"],["Node","Container enum for leaf and parent nodes."],["ProteusError","Wrapper for Proteus-related errors"],["PublicGroupStatePayload","Represents the byte array in [PublicGroupStateBundle]"]],"mod":[["config","Conversation configuration."],["decrypt","MLS defines 3 kind of messages: Proposal, Commits and Application messages. Since they can (should) be all encrypted we need to first decrypt them before deciding what to do with them."],["encrypt","Application messages are actual text messages user exchange. In MLS they can only be encrypted."],["export","Primitives to export data from a group, such as derived keys and client ids."],["handshake","Handshake refers here to either a commit or proposal message. Overall, it covers all the operation modifying the group state"],["merge","A MLS group can be merged (aka committed) when it has a pending commit. The latter is a commit we created which is still waiting to be “committed”. By doing so, we will apply all the modifications present in the commit to the ratchet tree and also persist the new group in the keystore. Like this, even if the application crashes we will be able to restore."]],"struct":[["CertificateBundle","Represents a x509 certificate chain supplied by the client It can fetch it after an end-to-end identity process where it can get back a certificate from the Authentication Service"],["Client","Represents a MLS client which in our case is the equivalent of a device. It can be the Android, iOS, web or desktop application which the authenticated user is using. A user has many client, a client has only one user. A client can belong to many MLS groups"],["ClientId","A unique identifier for clients. A client is an identifier for each App a user is using, such as desktop, mobile, etc. Users can have multiple clients. More information here"],["ConversationMember","Represents a client withing a group"],["Credential","Credential."],["EntropySeed","Wrapped 32-byte entropy seed with bounds check"],["GroupEpoch","Group epoch. Internally this is stored as a `u64`. The group epoch is incremented with every valid Commit that is merged into the group state."],["KeyPackage","The key package struct."],["MlsCentralConfiguration","Configuration parameters for `MlsCentral`"],["MlsCommitBundle","Returned when a commit is created"],["MlsConversation","This type will store the state of a group. With the [MlsGroup] it holds, it provides all operations that can be done in a group, such as creating proposals and commits. More information here"],["MlsConversationConfiguration","The configuration parameters for a group/conversation"],["MlsConversationCreationMessage","Returned when initializing a conversation through a commit. Different from conversation created from a [`Welcome`] message or an external commit."],["MlsConversationDecryptMessage","Represents the potential items a consumer might require after passing us an encrypted message we have decrypted for him"],["MlsConversationInitBundle","Returned when a commit is created"],["MlsCustomConfiguration","The configuration parameters for a group/conversation which are not handled natively by openmls"],["MlsGroup","A `MlsGroup` represents an MLS group with a high-level API. The API exposes high level functions to manage a group by adding/removing members, get the current member list, etc."],["MlsGroupConfig","Specifies the configuration parameters for a [`MlsGroup`]. Refer to the User Manual for more information about the different configuration values."],["MlsProposalBundle","Returned when a commit is created"],["MlsProposalRef","Abstraction over a [openmls::prelude::hash_ref::ProposalRef] to deal with conversions"],["MlsPublicGroupStateBundle","A [PublicGroupState] with metadata"],["VerifiablePublicGroupState","The [`VerifiablePublicGroupState`] represents a [`PublicGroupState`] of which the signature has not been verified. It implements the [`Verifiable`] trait and can thus be turned into a [`PublicGroupState`] by calling `verify(...)` with the `Credential` corresponding to the `CredentialBundle` of the signer. When receiving a serialized [`PublicGroupState`], it can thus only be deserialized into a [`VerifiablePublicGroupState`], which can then be turned into a [`PublicGroupState`] as described above."]],"type":[["ConversationId","A unique identifier for a group/conversation. The identifier must be unique within a client."],["CryptoResult","A simpler definition for Result types that the Error is a [CryptoError]"],["KeyPackageRef","A reference to a key package. This value uniquely identifies a key package."],["MemberId","Type definition for the identifier of a client in a conversation (aka Member)"],["RawEntropySeed","32-byte raw entropy seed"]]};