// Wire
// Copyright (C) 2022 Wire Swiss GmbH

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.

use std::io::Write;

use openmls::prelude::{MlsGroup, MlsMessageOut, VerifiablePublicGroupState};
use openmls_traits::OpenMlsCryptoProvider;

use core_crypto_keystore::CryptoKeystoreMls;

use crate::conversation::public_group_state::PublicGroupStateBundle;
use crate::{
    prelude::{MlsConversation, MlsConversationConfiguration},
    ConversationId, CryptoResult, MlsCentral, MlsError,
};

impl MlsCentral {
    /// Issues an external commit and stores the group in a temporary table. This method is
    /// intended for example when a new client wants to join the user's existing groups.
    /// On success this function will return the group id and a message to be fanned out to other
    /// clients.
    ///
    /// # Arguments
    /// * `group_state` - a verifiable public group state. it can be obtained by deserializing a TLS
    /// serialized `PublicGoupState` object
    ///
    /// # Return type
    /// It will return a tuple with the group/conversation id and the message containing the
    /// commit that was generated by this call
    ///
    /// # Errors
    /// Errors resulting from OpenMls, the KeyStore calls and serialization
    pub async fn join_by_external_commit(
        &self,
        group_state: VerifiablePublicGroupState,
    ) -> CryptoResult<(ConversationId, MlsExternalCommitBundle)> {
        let credentials = self.mls_client.credentials();
        let cfg = MlsConversationConfiguration::default().as_openmls_default_configuration()?;
        let (mut group, commit, pgs) =
            MlsGroup::join_by_external_commit(&self.mls_backend, None, group_state, &cfg, &[], credentials)
                .await
                .map_err(MlsError::from)?;

        let mut group_serialized = vec![];
        group.save(&mut group_serialized)?;

        self.mls_backend
            .key_store()
            .mls_pending_groups_save(group.group_id().as_slice(), &group_serialized)
            .await?;
        let bundle = MlsExternalCommitBundle {
            commit,
            public_group_state: PublicGroupStateBundle::try_new_full_unencrypted(pgs)?,
        };
        Ok((group.group_id().to_vec(), bundle))
    }

    /// This merges the commit generated by the external commit, persists the group permanently and
    /// deletes the temporary. After merging, the group should be fully functional.
    ///
    /// # Arguments
    /// * `id` - conversation id
    /// * `configuration` - the configuration to be applied by the new group on this client
    ///
    /// # Errors
    /// Errors resulting from OpenMls, the KeyStore calls and deserialization
    pub async fn merge_pending_group_from_external_commit(
        &mut self,
        id: &ConversationId,
        configuration: MlsConversationConfiguration,
    ) -> CryptoResult<()> {
        // Retrieve the pending MLS group from the keystore
        let keystore = self.mls_backend.key_store();
        let buf = keystore.mls_pending_groups_load(id).await?;
        let mut mls_group = MlsGroup::load(&mut &buf[..])?;

        // Merge it i.e. bring the MLS group to life and make it usable
        mls_group.merge_pending_commit().map_err(MlsError::from)?;

        // Persist the now usable MLS group inn the keystore
        // TODO: find a way to make the insertion of the MlsGroup and deletion of the pending group transactional
        let conversation = MlsConversation::from_mls_group(mls_group, configuration, &self.mls_backend).await?;
        self.mls_groups.insert(id.clone(), conversation);

        // cleanup the pending group we no longer need
        keystore.mls_pending_groups_delete(id).await?;
        Ok(())
    }
}

/// Returned when an external commit is created
#[derive(Debug, tls_codec::TlsSize)]
pub struct MlsExternalCommitBundle {
    /// The external commit message
    pub commit: MlsMessageOut,
    /// [`PublicGroupState`] (aka GroupInfo) only relevant when the commit is merged
    pub public_group_state: PublicGroupStateBundle,
}

impl tls_codec::Serialize for MlsExternalCommitBundle {
    fn tls_serialize<W: Write>(&self, writer: &mut W) -> Result<usize, tls_codec::Error> {
        self.commit
            .tls_serialize(writer)
            .and_then(|w| self.public_group_state.tls_serialize(writer).map(|l| l + w))
    }
}

#[cfg(test)]
mod tests {
    use openmls::prelude::*;
    use wasm_bindgen_test::*;

    use core_crypto_keystore::{CryptoKeystoreError, CryptoKeystoreMls, MissingKeyErrorKind};

    use crate::{credential::CredentialSupplier, test_utils::*, MlsConversationConfiguration, MlsError};

    wasm_bindgen_test_configure!(run_in_browser);

    #[apply(all_credential_types)]
    #[wasm_bindgen_test]
    pub async fn join_by_external_commit_should_succeed(credential: CredentialSupplier) {
        run_test_with_client_ids(
            credential,
            ["alice", "bob"],
            move |[mut alice_central, mut bob_central]| {
                Box::pin(async move {
                    let id = conversation_id();
                    alice_central
                        .new_conversation(id.clone(), MlsConversationConfiguration::default())
                        .await
                        .unwrap();

                    // export Alice group info
                    let public_group_state = alice_central.verifiable_public_group_state(&id).await;

                    // Bob tries to join Alice's group
                    let (conversation_id, external_commit) =
                        bob_central.join_by_external_commit(public_group_state).await.unwrap();
                    assert_eq!(conversation_id.as_slice(), &id);

                    // Alice decrypts the external commit and adds Bob
                    assert_eq!(alice_central[&id].members().len(), 1);
                    alice_central
                        .decrypt_message(&id, &external_commit.commit.to_bytes().unwrap())
                        .await
                        .unwrap();
                    assert_eq!(alice_central[&id].members().len(), 2);

                    // Let's say backend accepted our external commit.
                    // So Bob can merge the commit and update the local state
                    assert!(bob_central.get_conversation(&conversation_id).is_err());
                    bob_central
                        .merge_pending_group_from_external_commit(
                            &conversation_id,
                            MlsConversationConfiguration::default(),
                        )
                        .await
                        .unwrap();
                    assert!(bob_central.get_conversation(&conversation_id).is_ok());
                    assert_eq!(bob_central[&conversation_id].members().len(), 2);
                    assert!(alice_central.talk_to(&conversation_id, &mut bob_central).await.is_ok());

                    // Pending group removed from keystore
                    let error = alice_central.mls_backend.key_store().mls_pending_groups_load(&id).await;
                    assert!(matches!(
                        error.unwrap_err(),
                        CryptoKeystoreError::MissingKeyInStore(MissingKeyErrorKind::MlsPendingGroup)
                    ));
                })
            },
        )
        .await
    }

    #[apply(all_credential_types)]
    #[wasm_bindgen_test]
    pub async fn join_by_external_commit_should_be_retriable(credential: CredentialSupplier) {
        run_test_with_client_ids(
            credential,
            ["alice", "bob"],
            move |[mut alice_central, mut bob_central]| {
                Box::pin(async move {
                    let id = conversation_id();
                    alice_central
                        .new_conversation(id.clone(), MlsConversationConfiguration::default())
                        .await
                        .unwrap();

                    // export Alice group info
                    let public_group_state = alice_central.verifiable_public_group_state(&id).await;

                    // Bob tries to join Alice's group
                    bob_central
                        .join_by_external_commit(public_group_state.clone())
                        .await
                        .unwrap();
                    // BUT for some reason the Delivery Service will reject this external commit
                    // e.g. another commit arrived meanwhile and the [PublicGroupState] is no longer valid

                    // Retrying
                    let (conversation_id, external_commit) =
                        bob_central.join_by_external_commit(public_group_state).await.unwrap();
                    assert_eq!(conversation_id.as_slice(), &id);

                    // Alice decrypts the external commit and adds Bob
                    assert_eq!(alice_central[&id].members().len(), 1);
                    alice_central
                        .decrypt_message(&id, &external_commit.commit.to_bytes().unwrap())
                        .await
                        .unwrap();
                    assert_eq!(alice_central[&id].members().len(), 2);

                    // And Bob can merge its external commit
                    bob_central
                        .merge_pending_group_from_external_commit(&id, MlsConversationConfiguration::default())
                        .await
                        .unwrap();
                    assert!(bob_central.get_conversation(&id).is_ok());
                    assert_eq!(bob_central[&id].members().len(), 2);
                    assert!(alice_central.talk_to(&id, &mut bob_central).await.is_ok());
                })
            },
        )
        .await
    }

    #[apply(all_credential_types)]
    #[wasm_bindgen_test]
    pub async fn join_by_external_commit_bad_epoch_should_fail(credential: CredentialSupplier) {
        run_test_with_client_ids(credential, ["alice", "bob"], move |[mut alice_central, bob_central]| {
            Box::pin(async move {
                let id = conversation_id();
                alice_central
                    .new_conversation(id.clone(), MlsConversationConfiguration::default())
                    .await
                    .unwrap();

                let public_group_state = alice_central.verifiable_public_group_state(&id).await;
                // try to make an external join into Alice's group
                let (_, external_commit) = bob_central.join_by_external_commit(public_group_state).await.unwrap();

                // Alice creates a new commit before receiving the external join
                alice_central.update_keying_material(&id).await.unwrap();
                alice_central.commit_accepted(&id).await.unwrap();

                // receiving the external join with outdated epoch should fail because of
                // the wrong epoch
                let result = alice_central
                    .decrypt_message(&id, &external_commit.commit.to_bytes().unwrap())
                    .await;
                assert!(matches!(
                    result.unwrap_err(),
                    crate::CryptoError::MlsError(MlsError::MlsParseMessageError(ParseMessageError::ValidationError(
                        ValidationError::WrongEpoch
                    )))
                ));
            })
        })
        .await
    }

    #[apply(all_credential_types)]
    #[wasm_bindgen_test]
    pub async fn self_joins_by_external_commit_should_fail(credential: CredentialSupplier) {
        run_test_with_client_ids(credential, ["alice"], move |[mut alice_central]| {
            Box::pin(async move {
                let id = conversation_id();
                alice_central
                    .new_conversation(id.clone(), MlsConversationConfiguration::default())
                    .await
                    .unwrap();
                let public_group_state = alice_central.verifiable_public_group_state(&id).await;
                let join_self = alice_central.join_by_external_commit(public_group_state).await;
                assert!(matches!(
                    join_self.unwrap_err(),
                    crate::CryptoError::MlsError(MlsError::MlsExternalCommitError(ExternalCommitError::CommitError))
                ))
            })
        })
        .await
    }

    #[apply(all_credential_types)]
    #[wasm_bindgen_test]
    pub async fn merge_pending_external_should_fail_when_no_pending_commit(credential: CredentialSupplier) {
        run_test_with_central(credential, move |[mut central]| {
            Box::pin(async move {
                let id = conversation_id();
                // try to merge an inexisting pending group
                let merge_unknown = central
                    .merge_pending_group_from_external_commit(&id, MlsConversationConfiguration::default())
                    .await;

                assert!(matches!(
                    merge_unknown.unwrap_err(),
                    crate::CryptoError::KeyStoreError(CryptoKeystoreError::MissingKeyInStore(
                        MissingKeyErrorKind::MlsPendingGroup
                    ))
                ));
            })
        })
        .await
    }

    #[apply(all_credential_types)]
    #[wasm_bindgen_test]
    pub async fn join_by_external_commit_should_return_valid_public_group_state(credential: CredentialSupplier) {
        run_test_with_client_ids(
            credential,
            ["alice", "bob", "charlie"],
            move |[mut alice_central, mut bob_central, mut charlie_central]| {
                Box::pin(async move {
                    let id = conversation_id();
                    alice_central
                        .new_conversation(id.clone(), MlsConversationConfiguration::default())
                        .await
                        .unwrap();

                    // export Alice group info
                    let public_group_state = alice_central.verifiable_public_group_state(&id).await;

                    // Bob tries to join Alice's group
                    let (_, bob_external_commit) =
                        bob_central.join_by_external_commit(public_group_state).await.unwrap();

                    // Alice decrypts the commit, Bob's in !
                    alice_central
                        .decrypt_message(&id, &bob_external_commit.commit.to_bytes().unwrap())
                        .await
                        .unwrap();
                    assert_eq!(alice_central[&id].members().len(), 2);

                    // Bob merges the commit, he's also in !
                    bob_central
                        .merge_pending_group_from_external_commit(&id, MlsConversationConfiguration::default())
                        .await
                        .unwrap();
                    assert!(bob_central.get_conversation(&id).is_ok());
                    assert_eq!(bob_central[&id].members().len(), 2);
                    assert!(alice_central.talk_to(&id, &mut bob_central).await.is_ok());

                    // Now charlie wants to join with the [PublicGroupState] from Bob's external commit
                    let bob_pgs = bob_external_commit.public_group_state.get_pgs();
                    let (_, charlie_external_commit) = charlie_central.join_by_external_commit(bob_pgs).await.unwrap();

                    // Both Alice & Bob decrypt the commit
                    alice_central
                        .decrypt_message(&id, charlie_external_commit.commit.to_bytes().unwrap())
                        .await
                        .unwrap();
                    bob_central
                        .decrypt_message(&id, charlie_external_commit.commit.to_bytes().unwrap())
                        .await
                        .unwrap();
                    assert_eq!(alice_central[&id].members().len(), 3);
                    assert_eq!(bob_central[&id].members().len(), 3);

                    // Charlie merges the commit, he's also in !
                    charlie_central
                        .merge_pending_group_from_external_commit(&id, MlsConversationConfiguration::default())
                        .await
                        .unwrap();
                    assert!(charlie_central.get_conversation(&id).is_ok());
                    assert_eq!(charlie_central[&id].members().len(), 3);
                    assert!(charlie_central.talk_to(&id, &mut alice_central).await.is_ok());
                    assert!(charlie_central.talk_to(&id, &mut bob_central).await.is_ok());
                })
            },
        )
        .await
    }
}
